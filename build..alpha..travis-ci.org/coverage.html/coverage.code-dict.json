{"/home/travis/build/npmtest/node-npmtest-solr-client/test.js":"/* istanbul instrument in package npmtest_solr_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-solr-client/lib.npmtest_solr_client.js":"/* istanbul instrument in package npmtest_solr_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_solr_client = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_solr_client = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-solr-client/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-solr-client && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_solr_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_solr_client\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_solr_client.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_solr_client.rollup.js'] =\n            local.assetsDict['/assets.npmtest_solr_client.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_solr_client.__dirname + '/lib.npmtest_solr_client.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-solr-client/node_modules/solr-client/main.js":"/*!\n * solr client\n * Copyright(c) 2011-2012 HipSnip Limited\n * Author Rémy Loubradou <remyloubradou@gmail.com>\n * MIT Licensed\n */\n\nmodule.exports = exports = require(\"./lib/solr\");\n\n\n","/home/travis/build/npmtest/node-npmtest-solr-client/node_modules/solr-client/lib/solr.js":"/*!\n * solr client\n * Copyright(c) 2011-2012 HipSnip Limited\n * Copyright(c) 2013-2014 Rémy Loubradou\n * Author Rémy Loubradou <remyloubradou@gmail.com>\n * MIT Licensed\n */\n\n/**\n * Load dependencies\n */\n\nvar http = require('http'),\n   https = require('https'),\n   Query = require('./query'),\n   Collection = require('./collection'),\n   querystring = require('querystring'),\n   format = require('./utils/format'),\n   SolrError = require('./error/solr-error'),\n   JSONStream = require('JSONStream'),\n   duplexer = require('duplexer'),\n   request = require('request'),\n   JSONbig = require('json-bigint'),\n   versionUtils = require('./utils/version');\n\n/**\n * Expose `createClient()`.\n */\n\nexports.createClient = createClient;\n\n/**\n * Create an instance of `Client`\n *\n * @param {String|Object} [host='127.0.0.1'] - IP address or host address of the Solr server\n * @param {Number|String} [port='8983'] - port of the Solr server\n * @param {String} [core=''] - name of the Solr core requested\n * @param {String} [path='/solr'] - root path of all requests\n * @param {http.Agent} [agent] - HTTP Agent which is used for pooling sockets used in HTTP(s) client requests\n * @param {Boolean} [secure=false] - if true HTTPS will be used instead of HTTP\n * @param {Boolean} [bigint=false] - if true JSONbig serializer/deserializer will be used instead\n *                                    of JSON native serializer/deserializer\n * @param solrVersion ['3.2', '4.0', '5.0', '5.1'], check lib/utils/version.js for full reference\n *\n * @return {Client}\n * @api public\n */\n\nfunction createClient(host, port, core, path, agent, secure, bigint, solrVersion){\n  var options = (typeof host === 'object') ? host : {\n      host : host,\n      port : port,\n      core : core,\n      path : path,\n      agent : agent,\n      secure : secure,\n      bigint : bigint,\n      solrVersion: solrVersion\n   };\n  return new Client(options);\n}\n\n/**\n * Solr client\n * @constructor\n *\n * @param {Object} options - set of options used to request the Solr server\n * @param {String} options.host - IP address or host address of the Solr server\n * @param {Number|String} options.port - port of the Solr server\n * @param {String} options.core - name of the Solr core requested\n * @param {String} options.path - root path of all requests\n * @param {http.Agent} [options.agent] - HTTP Agent which is used for pooling sockets used in HTTP(s) client requests\n * @param {Boolean} [options.secure=false] - if true HTTPS will be used instead of HTTP\n * @param {Boolean} [options.bigint=false] - if true JSONbig serializer/deserializer will be used instead\n *                                    of JSON native serializer/deserializer\n *\n * @return {Client}\n * @api private\n */\n\nfunction Client(options){\n   this.options = {\n      host : options.host || '127.0.0.1',\n      port : options.port || '8983',\n      core : options.core || '',\n      path : options.path || '/solr',\n      agent : options.agent,\n      secure : options.secure || false,\n      bigint : options.bigint || false,\n      get_max_request_entity_size: options.get_max_request_entity_size || false,\n      solrVersion: options.solrVersion || versionUtils.Solr3_2\n   };\n\n   // Default paths of all request handlers\n   this.UPDATE_JSON_HANDLER = (versionUtils.version(this.options.solrVersion) >= versionUtils.Solr4_0) ? 'update' : 'update/json';\n   this.UPDATE_HANDLER = 'update';\n   this.SELECT_HANDLER = 'select';\n   this.COLLECTIONS_HANDLER = 'admin/collections';\n   this.ADMIN_PING_HANDLER = 'admin/ping';\n   this.REAL_TIME_GET_HANDLER = 'get';\n   this.SPELL_HANDLER = 'spell';\n}\n\n/**\n * Create credential using the basic access authentication method\n *\n * @param {String} username\n * @param {String} password\n *\n * @return {Client}\n * @api public\n */\n\nClient.prototype.basicAuth = function(username,password){\n   var self = this;\n   this.options.authorization = 'Basic ' + new Buffer(username + ':' + password).toString('base64');\n   return self;\n}\n\n/**\n * Remove authorization header\n *\n * @return {Client}\n * @api public\n */\n\nClient.prototype.unauth = function(){\n   var self = this;\n   delete this.options.authorization;\n   return self;\n}\n\n/**\n * Add a document or a list of documents\n *\n * @param {Object|Array} doc - document or list of documents to add into the Solr database\n * @param {Object} [options] -\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api public\n */\n\nClient.prototype.add = function(docs,options,callback){\n   if(typeof(options) === 'function'){\n      callback = options;\n      options = {};\n   }\n   docs = format.dateISOify(docs); // format `Date` object into string understable for Solr as a date.\n   docs = Array.isArray(docs) ? docs : [docs];\n   return this.update(docs,options,callback);\n}\n\n/**\n * Get a document by id or a list of documents by ids using the Real-time-get feature\n *  in SOLR4 (https://wiki.apache.org/solr/RealTimeGet)\n *\n * @param {String|Array} ids - id or list of ids that identify the documents to get\n * @param {Query|Object|String} [query] -\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api public\n */\n\nClient.prototype.realTimeGet = function(ids, query, callback){\n   if(typeof query === 'function'){\n      callback = query;\n      query = {};\n   }\n   ids = Array.isArray(ids) ? ids : [ids];\n   query.ids = ids.join(',');\n\n   return this.get(this.REAL_TIME_GET_HANDLER,query,callback);\n}\n\n/**\n * Add the remote resource located at the given path `options.path` into the Solr database.\n *\n * @param {Object} options -\n * @param {String} options.path - path of the file. HTTP URL, the full path or a path relative to the CWD of the running solr server must be used.\n * @param {String} [options.format='xml'] - format of the resource. XML, CSV or JSON formats must be used.\n * @param {String} [options.contentType='text/plain;charset=utf-8'] - content type of the resource\n * @param {Object} [options.parameters] - set of extras parameters pass along in the query.\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api public\n */\n\nClient.prototype.addRemoteResource = function(options,callback){\n   options.parameters = options.parameters || {};\n   options.format = (options.format === 'xml' ? '' : options.format || ''); // reason: the default route of the XmlUpdateRequestHandle is /update and not /update/xml.\n   options.parameters.commit = (options.parameters.commit === undefined ? false : options.parameters.commit);\n   options.parameters['stream.contentType'] = options.contentType || 'text/plain;charset=utf-8';\n   if(options.path.match(/^https?:\\/\\//)){\n      options.parameters['stream.url'] = options.path;\n   }else{\n      options.parameters['stream.file'] = options.path;\n   }\n\n   var handler = this.UPDATE_HANDLER + '/' + options.format.toLowerCase();\n   var query = querystring.stringify(options.parameters);\n   return this.get(handler,query,callback);\n}\n\n/**\n * Create a writable/readable `Stream` to add documents into the Solr database\n *\n * @param {Object} [options] -\n *\n * return {Stream}\n * @api public\n */\n\nClient.prototype.createAddStream = function(options){\n   var path = [this.options.path,this.options.core, this.UPDATE_JSON_HANDLER + '?' + querystring.stringify(options) +'&wt=json']\n      .filter(function(element){\n         return element;\n      })\n      .join('/');\n   var headers = {\n      'content-type' : 'application/json',\n      'charset' : 'utf-8'\n   };\n   if(this.options.authorization){\n      headers['authorization'] = this.options.authorization;\n   }\n   var protocol = this.options.secure ? 'https' : 'http';\n   var optionsRequest = {\n      url : protocol + '://' + this.options.host +':' + this.options.port + path ,\n      method : 'POST',\n      headers : headers\n   };\n   var jsonStreamStringify = JSONStream.stringify();\n   var postRequest = request(optionsRequest);\n   jsonStreamStringify.pipe(postRequest);\n   var duplex = duplexer(jsonStreamStringify,postRequest);\n   return duplex ;\n}\n\n/**\n * Commit last added and removed documents, that means your documents are now indexed.\n *\n * @param {Object} options\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api public\n */\n\nClient.prototype.commit = function(options,callback){\n   if(typeof(options) === 'function'){\n      callback = options;\n      options = {};\n   }\n   var data = {\n      commit : options || {}\n   };\n   return this.update(data,callback);\n}\n\n/**\n * Call Lucene's IndexWriter.prepareCommit, the changes won't be visible in the index.\n *\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api public\n */\n\nClient.prototype.prepareCommit = function(callback){\n   return this.update({},{ prepareCommit : true},callback);\n}\n\n/**\n * Soft commit all changes\n *\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api public\n */\n\nClient.prototype.softCommit = function(callback){\n   return this.update({},{ softCommit : true},callback);\n}\n\n/**\n * Delete documents based on the given `field` and `text`.\n *\n * @param {String} field\n * @param {String} text\n * @param {Object} [options]\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api public\n */\n\nClient.prototype.delete = function(field,text,options,callback) {\n   if(typeof(options) === 'function'){\n      callback = options;\n      options = {};\n   }\n   text = format.dateISOify(text);\n   var data = {\n      'delete' :  {\n         query : field +  ':'  + format.escapeSpecialChars(text)\n      }\n   };\n   return this.update(data,options,callback);\n}\n\n/**\n * Delete a range of documents based on the given `field`, `start` and `stop` arguments.\n *\n * @param {String} field\n * @param {String|Date} start\n * @param {String|Date} stop\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api public\n */\n\nClient.prototype.deleteByRange = function(field,start,stop,options,callback){\n   if(typeof(options) === 'function'){\n      callback = options;\n      options = {};\n   }\n   start = format.dateISOify(start);\n   stop = format.dateISOify(stop);\n\n   var query = field + ':[' + start + ' TO ' + stop + ']';\n   return this.deleteByQuery(query,options,callback);\n}\n\n/**\n * Delete the document with the given `id`\n *\n * @param {String|Number} id - id of the document you want to delete\n * @param {Object} [options] -\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api public\n */\n\nClient.prototype.deleteByID = function(id,options,callback){\n   if(typeof(options) === 'function'){\n      callback = options;\n      options = {};\n   }\n   var data = {\n      'delete' : {\n         id : id\n      }\n   };\n   return this.update(data,options,callback);\n}\n\n/**\n * Delete documents matching the given `query`\n *\n * @param {String} query -\n * @param {Object} [options] -\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api public\n */\n\nClient.prototype.deleteByQuery = function(query,options,callback){\n   if(typeof(options) === 'function'){\n      callback = options;\n      options = {};\n   }\n   var data = {\n      'delete' : {\n         query : query\n      }\n   };\n   return this.update(data,options,callback);\n}\n\n\n/**\n * Delete all documents\n *\n * @param {Object} [options] -\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api public\n */\n\nClient.prototype.deleteAll = function(options,callback){\n   return this.deleteByQuery('*:*',options,callback);\n}\n\n/**\n * Optimize the index\n *\n * @param {Object} options -\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api public\n */\n\nClient.prototype.optimize = function(options,callback){\n   if(typeof(options) === 'function'){\n      callback = options;\n      options = {};\n   }\n   var data = {\n      optimize : options || {}\n   };\n   return this.update(data,callback);\n}\n\n/**\n * Rollback all add/delete commands made since the last commit.\n *\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api public\n */\n\nClient.prototype.rollback = function(callback){\n   var data = {\n      rollback : {}\n   };\n   return this.update(data,callback);\n}\n\n/**\n * Send an update command to the Solr server with the given `data` stringified in the body.\n *\n * @param {Object} data - data sent to the Solr server\n * @param {Object} [options] -\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api private\n */\n\nClient.prototype.update = function(data,options,callback){\n   if(typeof(options) === 'function'){\n      callback = options;\n      options = {};\n   }\n\n   var json = pickJSON(this.options.bigint).stringify(data);\n   var fullPath = [this.options.path,this.options.core, this.UPDATE_JSON_HANDLER + '?' + querystring.stringify(options) +'&wt=json']\n                              .filter(function(element){\n                                 return element;\n                              })\n                              .join('/');\n\n   var params = {\n      host : this.options.host,\n      port : this.options.port,\n      fullPath : fullPath,\n      json : json,\n      secure : this.options.secure,\n      bigint : this.options.bigint,\n      authorization : this.options.authorization,\n      agent : this.options.agent\n   };\n   return postJSON(params,callback);\n}\n\n/**\n * Search documents matching the `query`\n *\n * @param {Query|Object|String} query\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api public\n */\n\nClient.prototype.search = function(query,callback){\n   return this.get(this.SELECT_HANDLER, query, callback);\n}\n\n/**\n * Execute an Admin Collections task on `collection`\n *\n * @param {Query|Object|String} collection\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api public\n */\n\nClient.prototype.executeCollection = function(collection,callback){\n   return this.get(this.COLLECTIONS_HANDLER, collection, callback);\n}\n\n/**\n * Search for all documents\n *\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api public\n */\n\nClient.prototype.searchAll = function(callback){\n   return this.search('q=*', callback);\n}\n\n/**\n * Search documents matching the `query`\n *\n * Spellcheck is also enabled.\n *\n * @param {Query|Object|String} query\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api public\n */\n\nClient.prototype.spell = function(query,callback){\n   return this.get(this.SPELL_HANDLER, query, callback);\n}\n\n/**\n * Send an arbitrary HTTP GET request to Solr on the specified `handler` (as Solr like to call it i.e path)\n *\n * @param {String} handler\n * @param {Query|Object|String} [query]\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api public\n */\n\nClient.prototype.get = function(handler,query,callback){\n\n   var parameters = '';\n   if(typeof query === 'function'){\n      callback = query;\n   }else if((query instanceof Query) || (query instanceof Collection)){\n      parameters += query.build();\n   }else if(typeof query === 'object'){\n      parameters += querystring.stringify(query);\n   }else if(typeof query === 'string'){\n      parameters += query;\n   }\n   var pathArray;\n\n   if(handler != 'admin/collections'){\n      pathArray = [this.options.path,this.options.core,handler + '?' + parameters + '&wt=json'];\n   } else {\n      pathArray = [this.options.path,handler + '?' + parameters + '&wt=json'];\n   }\n\n   var fullPath = pathArray.filter(function(element){\n                 return element;\n              }).join('/');\n\n   var approxUrlLength = 10 + Buffer.byteLength(this.options.host) + (this.options.port+\"\").length + Buffer.byteLength(fullPath); // Buffer (10) accounts for protocol and special characters like ://, port colon, and initial slash etc\n\n   if (this.options.get_max_request_entity_size === false || approxUrlLength <= this.options.get_max_request_entity_size) {\n      var params = {\n         host: this.options.host,\n         port: this.options.port,\n         fullPath: fullPath,\n         secure: this.options.secure,\n         bigint: this.options.bigint,\n         authorization: this.options.authorization,\n         agent: this.options.agent\n      };\n      return getJSON(params, callback);\n   } else {\n\n      // Funnel this through a POST because it's too large\n      return this.post(handler, query, callback);\n   }\n}\n\n/**\n * Send an arbitrary HTTP POST request to Solr on the specified `handler` (as Solr like to call it i.e path)\n *\n * @param {String} handler\n * @param {Query|Object|String} [query]\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api public\n */\nClient.prototype.post = function(handler,query,callback){\n\n   var parameters = '';\n   if(typeof query === 'function'){\n      callback = query;\n   }else if(query instanceof Query){\n      parameters += query.build();\n   }else if(typeof query === 'object'){\n      parameters += querystring.stringify(query);\n   }else if(typeof query === 'string'){\n      parameters += query;\n   }\n\n   var pathArray;\n\n   if(handler != 'admin/collections'){\n      pathArray = [this.options.path,this.options.core,handler + '?' + parameters + '&wt=json'];\n   } else {\n      pathArray = [this.options.path,handler + '?' + parameters + '&wt=json'];\n   }\n\n   var fullPath = pathArray.filter(function(element){\n                 return element;\n              }).join('/');\n\n   var params = {\n      host : this.options.host,\n      port : this.options.port,\n      fullPath : fullPath,\n      params : parameters,\n      secure : this.options.secure,\n      bigint : this.options.bigint,\n      authorization : this.options.authorization,\n      agent : this.options.agent\n   };\n   return postForm(params,callback);\n}\n\n/**\n * Create an instance of `Query`\n *\n * @return {Query}\n * @api public\n */\n\nClient.prototype.query = function(){\n   return new Query(this.options);\n}\n\n/**\n * Create an instance of `Query`\n * NOTE: This method will be deprecated in the v0.6 release. Please use `Client.query()` instead.\n *\n * @return {Query}\n * @api public\n */\n\nClient.prototype.createQuery = function(){\n   return new Query(this.options);\n}\n\n/**\n * Create an instance of `Collection`\n *\n * @return {Collection}\n * @api public\n */\n\nClient.prototype.collection = function(){\n   return new Collection();\n}\n\n/**\n * Expose `format.escapeSpecialChars` from `Client.escapeSpecialChars`\n */\n\nClient.prototype.escapeSpecialChars = format.escapeSpecialChars;\n\n/**\n * Ping the Solr server\n *\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api public\n */\n\nClient.prototype.ping = function(callback){\n   return this.get(this.ADMIN_PING_HANDLER, callback);\n}\n\n/**\n * Pick appropriate protocol based on the given `secure` flag\n *\n * @param {Boolean} secure -\n * @return {Object} http or https module\n * @api private\n */\n\nfunction pickProtocol(secure){\n   return secure ? https : http;\n};\n\n\n/**\n * Pick appropriate JSON serializer/deserializer library based on the given `bigint` flag\n * @param {Boolean} bigint - whenever to handle big number correctly or not (the reason for not using JSONbig all the times is it has an important performance cost)\n * @return {Object} JSON or JSONbig serializer/deserializer\n * @api private\n */\n\nfunction pickJSON(bigint){\n   return bigint ? JSONbig : JSON;\n};\n\n/**\n * HTTP POST request. Send update commands to the Solr server (commit, add, delete, optimize)\n *\n * @param {Object} params\n * @param {String} params.host - IP address or host address of the Solr server\n * @param {Number|String} params.port - port of the Solr server\n * @param {String} params.core - name of the Solr core requested\n * @param {String} params.authorization - value of the authorization header\n * @param {String} params.fullPath - full path of the request\n * @param {String} params.json -\n * @param {Boolean} params.secure -\n * @param {Boolean} params.bigint -\n * @param {http.Agent} [params.agent] -\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api private\n */\n\nfunction postJSON(params,callback){\n   var headers = {\n      'content-type' : 'application/json; charset=utf-8',\n      'content-length':  Buffer.byteLength(params.json),\n      'accept' : 'application/json; charset=utf-8'\n   };\n   if(params.authorization){\n      headers['authorization'] = params.authorization;\n   }\n   var options = {\n      host : params.host,\n      port : params.port,\n      method : 'POST',\n      headers : headers,\n      path : params.fullPath\n   };\n\n   if(params.agent !== undefined){\n      options.agent = params.agent;\n   }\n\n   var request = pickProtocol(params.secure).request(options);\n\n   request.on('response', handleJSONResponse(request, params.bigint, callback));\n\n   request.on('error',function onError(err){\n      if (callback) callback(err,null);\n   });\n\n   request.write(params.json);\n   request.end();\n\n   return request;\n};\n\n/**\n * HTTP POST request. Send update commands to the Solr server using form encoding (e.g. search)\n *\n * @param {Object} params\n * @param {String} params.host - IP address or host address of the Solr server\n * @param {Number|String} params.port - port of the Solr server\n * @param {String} params.core - name of the Solr core requested\n * @param {String} params.authorization - value of the authorization header\n * @param {String} params.fullPath - full path of the request\n * @param {String} params.params - form params\n * @param {Boolean} params.secure -\n * @param {Boolean} params.bigint -\n * @param {http.Agent} [params.agent] -\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api private\n */\n\nfunction postForm(params,callback){\n   var headers = {\n      'content-type' : 'application/x-www-form-urlencoded; charset=utf-8',\n      'content-length':  Buffer.byteLength(params.params),\n      'accept' : 'application/json; charset=utf-8'\n   };\n   if(params.authorization){\n      headers['authorization'] = params.authorization;\n   }\n   var options = {\n      host : params.host,\n      port : params.port,\n      method : 'POST',\n      headers : headers,\n      path : params.fullPath\n   };\n\n   if(params.agent !== undefined){\n      options.agent = params.agent;\n   }\n\n   var request = pickProtocol(params.secure).request(options);\n\n   request.on('response', handleJSONResponse(request, params.bigint, callback));\n\n   request.on('error',function onError(err){\n      if (callback) callback(err,null);\n   });\n\n   request.write(params.params);\n   request.end();\n\n   return request;\n};\n\n/**\n * HTTP GET request.  Send a query command to the Solr server (query)\n *\n * @param {Object} params\n * @param {String} params.host - IP address or host address of the Solr server\n * @param {Number|String} params.port - port of the Solr server\n * @param {String} params.core - name of the Solr core requested\n * @param {String} params.authorization - value of the authorization header\n * @param {String} params.fullPath - full path of the request, contains query parameters\n * @param {Boolean} params.secure -\n * @param {Boolean} params.bigint -\n * @param {http.Agent} [params.agent] -\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @return {http.ClientRequest}\n * @api private\n */\n\nfunction getJSON(params,callback){\n   var headers = {\n      'accept' : 'application/json; charset=utf-8'\n   };\n   var options = {\n      host : params.host,\n      port : params.port,\n      path : params.fullPath,\n      headers : headers\n   };\n\n   if(params.agent !== undefined){\n      options.agent = params.agent;\n   }\n\n    if(params.authorization){\n      var headers = {\n         'authorization' : params.authorization\n      };\n      options.headers = headers;\n   }\n\n   var request = pickProtocol(params.secure).get(options);\n\n   request.on('response', handleJSONResponse(request, params.bigint, callback));\n\n   request.on('error',function(err){\n      if (callback) callback(err,null);\n   });\n   return request;\n};\n\n/**\n * Handle HTTP JSON response from Solr\n *\n * @param {Function} callback(err,obj) - a function executed when the Solr server responds or an error occurs\n * @param {Error} callback().err\n * @param {Object} callback().obj - JSON response sent by the Solr server deserialized\n *\n * @api private\n */\n\nfunction handleJSONResponse(request, bigint, callback){\n   return function onJSONResponse(response){\n      var text = '';\n      var err = null;\n      var data = null;\n\n      // This properly handles multi-byte characters\n      response.setEncoding('utf-8');\n\n      response.on('data',function(chunk){\n         text += chunk;\n      });\n\n      response.on('end',function(){\n         if(response.statusCode < 200 || response.statusCode > 299){\n            err = new SolrError(request,response,text);\n            if(callback)  callback(err,null);\n         }else{\n            try{\n               data = pickJSON(bigint).parse(text);\n            }catch(error){\n               err = error;\n            }finally{\n               if(callback)  callback(err,data);\n            }\n         }\n      });\n   };\n};\n","/home/travis/build/npmtest/node-npmtest-solr-client/node_modules/solr-client/lib/query.js":"/**\n * Load dependencies\n */\nvar querystring = require('querystring'),\n    format = require('./utils/format'),\n    arrayUtils = require('./utils/array'),\n    versionUtils = require('./utils/version');\n\n/**\n * Expose `Query`\n */\n\nmodule.exports = exports = Query;\n\n/**\n * Create a new `Query`\n * @constructor\n *\n * @return {Query}\n * @api private\n */\n\nfunction Query(options){\n   this.solrVersion = (options && options.solrVersion) || undefined;\n   this.parameters = [];\n}\n\n/**\n * Set a new parameter\n * Since all possibilities provided by Solr are not available in the `Query` object, `set()` is there to fit this gap.\n *\n * @param {String} parameter - string, special characters have to be correctly encoded or the request will fail.\n *\n * @return {Query} - allow chaining\n * @api public\n */\nQuery.prototype.set = function(parameter){\n   var self = this;\n   this.parameters.push(parameter);\n   return self;\n}\n\n/**\n * Set the query parser to use with this request.\n *\n * @param {String} type - name of the query parser e.g: 'dismax'\n *\n * @return {Query}\n * @api public\n */\n\nQuery.prototype.defType = function(type){\n   var self = this;\n   var parameter = 'defType=' + type;\n   this.parameters.push(parameter);\n   return self;\n}\n\n/**\n * Set the Request Handler used to process the request based on its `name`.\n * Works only if no Request Handler has been configured with `/select` as its name in solrconfig.xml.\n *\n * @param {String} name - name of the Request Handler\n *\n * @return {Query}\n * @api public\n */\n\nQuery.prototype.requestHandler =\nQuery.prototype.qt = function(name){\n  var self = this;\n  var parameter = 'qt=' + name;\n  this.parameters.push(parameter);\n  return self;\n}\n\n/**\n *  Set the main query\n *\n * @param {String|Object} q -\n *\n * @return  {Query}\n * @api public\n */\n\nQuery.prototype.q = function(q){\n   var self = this;\n   var parameter ='q=';\n   if ( typeof(q) === 'string' ){\n      parameter += encodeURIComponent(q);\n   }else{\n      parameter += querystring.stringify(q, '%20AND%20',':');\n   }\n   this.parameters.push(parameter);\n   return self;\n}\n\n/**\n *  Set the default query operator\n *\n * @param {String} op -\n *\n * @return  {Query}\n * @api public\n */\n\nQuery.prototype.qop = function(op){\n    var self = this;\n    var parameter ='q.op=';\n    parameter += op;\n    this.parameters.push(parameter);\n    return self;\n};\n\n/**\n * Set the default query field.\n *\n * @param {String} df - the default field where solr should search.\n *\n * @return  {Query}\n * @api public\n */\nQuery.prototype.df = function (df) {\n    var self = this;\n    var parameter = 'df=';\n    parameter += df;\n    this.parameters.push(parameter);\n    return self;\n};\n\n/**\n * Set the offset where the set of returned documents should begin.\n *\n * @param {Number} start - the offset where the set of returned documents should begin.\n *\n * @return {Query}\n * @api public\n */\n\nQuery.prototype.start = function(start){\n   var self = this;\n   var parameter = 'start=' + start ;\n   this.parameters.push(parameter);\n   return self;\n}\n\n/**\n * Set the maximum number of documents returned\n *\n * @param {Number} rows - number of documents\n *\n * @return {Query}\n * @api public\n */\nQuery.prototype.rows = function(rows){\n   var self = this;\n   var parameter = 'rows=' + rows ;\n   this.parameters.push(parameter);\n   return self;\n}\n\n/**\n * Request to use cursorMarks for deep-paging as explained in http://heliosearch.org/solr/paging-and-deep-paging/\n * Note that usage of a cursor requires a sort containing a uniqueKey field tie breaker\n *\n * @param {String} mark - The mark to use, defaults to \"*\" to request a new cursor in the first request\n *\n * @return {Query}\n * @api public\n */\nQuery.prototype.cursorMark = function(mark){\n   var self = this;\n   mark = mark || \"*\";\n   var parameter = 'cursorMark=' + mark ;\n   this.parameters.push(parameter);\n   return self;\n}\n\n/**\n * Sort a result in descending or ascending order based on one or more fields.\n *\n * @param {Object} options -\n *\n * @return {Query}\n * @api public\n */\n\nQuery.prototype.sort = function(options){\n   var self = this;\n   var parameter = 'sort=';\n   parameter += querystring.stringify(options, ',' , '%20');\n   this.parameters.push(parameter);\n   return self;\n}\n\n/**\n * Filter the set of documents found before to return the result with the given range determined by `field`, `start` and `end`.\n *\n * @param {Array|Object} options -\n * @param {String} options.field - the name of the field where the range is applied\n * @param {String|Number|Date} options.start - the offset where the range starts\n * @param {String|Number|Date} options.end - the offset where the range ends\n *\n * @return {Query}\n * @api public\n *\n * @example\n * var query = client.createQuery();\n * query.q({ '*' : '*' }).rangeFilter({ field : 'id', start : 100, end : 200})\n * // also works\n * query.q({ '*' : '*' }).rangeFilter([{ field : 'id', start : 100, end : 200},{ field : 'date', start : new Date(), end : new Date() - 3600}]);\n */\n\nQuery.prototype.rangeFilter = function(options){\n   var self = this;\n   options = format.dateISOify(options);\n   var parameter = 'fq=';\n   if(Array.isArray(options)){\n     parameter += \"(\";\n      var filters = options.map(function(option){\n         var key = option.field;\n         var filter = {};\n         filter[key] = '[' + encodeURIComponent(option.start) + '%20TO%20' + encodeURIComponent(option.end) + ']';\n         return format.stringify(filter, '',':');\n      });\n      parameter += filters.join('%20AND%20');\n      parameter += \")\";\n   }else{\n      var key = options.field;\n      var filter = {};\n      filter[key] = '[' + encodeURIComponent(options.start) + '%20TO%20' + encodeURIComponent(options.end) + ']';\n      parameter += format.stringify(filter, '',':');\n   }\n   this.parameters.push(parameter);\n   return self;\n}\n\n/**\n * Filter the set of documents found before to return the result with the given `field` and `value`.\n *\n * @param {String} field - name of field\n * @param {String|Number|Date} value - value of the field that must match\n *\n * @return {Query}\n * @api public\n *\n * @example\n * var query = client.createQuery();\n * query.q({ '*' : '*' }).matchFilter('id', 100)\n */\n\nQuery.prototype.matchFilter = function(field,value){\n   var self = this;\n   value = format.dateISOify(value);\n   var parameter = 'fq=';\n   parameter += field + ':' + encodeURIComponent(value);\n   this.parameters.push(parameter);\n   return self;\n}\n\n/**\n * Specify a set of fields to return.\n *\n * @param {String|Array} field - field name\n *\n * @return {Query}\n * @api public\n */\n\nQuery.prototype.fl =\nQuery.prototype.restrict = function(fields){\n   var self = this;\n   var parameter = 'fl=';\n   if(typeof(fields) === 'string'){\n      parameter += fields;\n   }else{\n      parameter += fields.join(',');\n   }\n   this.parameters.push(parameter);\n   return self;\n}\n\n/**\n * Set the time allowed for a search to finish.\n * Partial results may be returned (if there are any).\n *\n * @param {String|Number} time - time is in milliseconds. Values <= 0 mean no time restriction.\n *\n * @return {Query}\n * @api public\n */\n\nQuery.prototype.timeout = function(time){\n   var self = this;\n   var parameter = 'timeAllowed=' + time;\n   this.parameters.push(parameter);\n   return self;\n}\n\n/**\n * Group documents with the given `field`\n *\n * @param {String} field - field name\n *\n * @return {Query}\n * @api public\n */\n\nQuery.prototype.groupBy = function(field){\n   var self = this;\n   this.group({\n      'field': field\n   });\n   return self;\n}\n\n/**\n * Group documents using field collapsing or result grouping feature.\n * Field Collapsing collapses a group of results with the same field value down to a single (or fixed number) of entries.\n * Result Grouping groups documents with a common field value into groups, returning the top documents per group, and the top groups based on what documents are in the groups.\n *\n * @param {Object} options\n * @param {Boolean} [options.on=true] - if false, turn off result grouping, otherwise turn on.\n * @param {String|Array} options.field - Group based on the unique values of a field.\n * @param {Number} [options.limit=1] - The number of results (documents) to return for each group. Solr's default value is 1.\n * @param {Number} options.offset - The offset into the document list of each group.\n * @param {String} [options.sort=\"score desc\"] - How to sort documents within a single group. Defaults to the same value as the sort parameter.\n * @param {String} options.format - if simple, the grouped documents are presented in a single flat list. The start and rows parameters refer to numbers of documents instead of numbers of groups.\n * @param {Boolean} options.main - If true, the result of the last field grouping command is used as the main result list in the response, using group.format=simple.\n * @param {Boolean} [options.ngroups=false] - If true, includes the number of groups that have matched the query. Default is false.\n * @param {Boolean} options.truncate - If true, facet counts are based on the most relevant document of each group matching the query. Same applies for StatsComponent. Default is false.\n * @param {Number}  [options.cache=0] - If > 0 enables grouping cache. Grouping is executed actual two searches. This option caches the second search. A value of 0 disables grouping caching. Default is 0.\n *\n * @return {Query}\n * @api public\n */\n\nQuery.prototype.group = function(options){\n   var self = this;\n   if(options.on === false){\n      this.parameters.push('group=false');\n   }else{\n      this.parameters.push('group=true');\n   }\n   if( options.field ){\n      options.field = arrayUtils.toArray(options.field);\n      options.field.forEach(function(field){\n        self.parameters.push('group.field=' + field);\n      });\n   }\n   if( options.limit !== undefined){\n      this.parameters.push('group.limit=' + options.limit);\n   }\n   if( options.offset !== undefined){\n      this.parameters.push('group.offset=' + options.offset);\n   }\n   if( options.sort ){\n      this.parameters.push('group.sort=' + encodeURIComponent(options.sort));\n   }\n   if( options.format ){\n      this.parameters.push('group.format=' + encodeURIComponent(options.format));\n   }\n   if( options.main !== undefined){\n      this.parameters.push('group.main=' + options.main);\n   }\n   if( options.ngroups !== undefined){\n      this.parameters.push('group.ngroups=' + options.ngroups);\n   }\n   if( options.truncate !== undefined){\n      this.parameters.push('group.truncate=' + options.truncate);\n   }\n   if( options.cache !== undefined){\n      this.parameters.push('group.cache.percent=' + options.cache);\n   }\n   return self;\n}\n\n/**\n * Create a facet\n *\n * @param {Object} options - set of options to create a facet\n * @param {Boolean} [options.on=true] - Turn on or off facet\n * @param {String} [options.query] - This parameter allows you to specify an arbitrary query in the Lucene default syntax to generate a facet count. By default, faceting returns a count of the unique terms for a \"field\", while facet.query allows you to determine counts for arbitrary terms or expressions.\n * @param {String|Array} options.field - This parameter allows you to specify a field which should be treated as a facet. It will iterate over each Term in the field and generate a facet count using that Term as the constraint. Multiple fields can be defined providing an array instead of a string.\n * @param {String} [options.prefix] - Limits the terms on which to facet to those starting with the given string prefix.\n * @param {String} [options.sort] - This param determines the ordering of the facet field constraints.count\n * @param {Number} [options.limit=100] - This parameter indicates the maximum number of constraint counts that should be returned for the facet fields. A negative value means unlimited.The solr's default value is 100.\n * @param {Number} [options.offset=0] - This param indicates an offset into the list of constraints to allow paging.The solr's default value is 0.\n * @param {Number} [options.mincount=0] - This parameter indicates the minimum counts for facet fields should be included in the response. The solr's default value is 0.\n * @param {Boolean} [options.missing=false] - Set to `true` this param indicates that in addition to the Term based constraints of a facet field, a count of all matching results which have no value for the field should be computed. The solr's default value is false.\n * @param {String} [options.method=\"fc\"] - This parameter indicates what type of algorithm/method to use when faceting a field.The solr's default value is fc (except for BoolField).\n * @param {String|Array} options.pivot - This parameter allows you to specify a field which should be treated as a facet pivot. It will iterate over each Term in the field. Multiple fields can be defined providing an array instead of a string.\n * @param {String} [options.pivot.mincount=0] - This parameter indicates the minimum counts for facet pivot fields to be included in the response. The solr's default value is 0.\n *\n * @return {Query}\n * @api public\n */\nQuery.prototype.facet = function(options){\n   var self = this;\n   if(options.on === false){\n      this.parameters.push('facet=false');\n   }else{\n      this.parameters.push('facet=true');\n   }\n   if(options.query){\n      this.parameters.push('facet.query=' + encodeURIComponent(options.query))\n   }\n   if(options.field){\n     options.field = arrayUtils.toArray(options.field);\n     options.field.forEach(function(field) {\n       self.parameters.push('facet.field=' + field);\n     });\n   }\n   if(options.prefix){\n      this.parameters.push('facet.prefix=' + encodeURIComponent(options.prefix))\n   }\n   if(options.sort){\n      this.parameters.push('facet.sort=' + encodeURIComponent(options.sort))\n   }\n   if(options.limit !== undefined){\n      this.parameters.push('facet.limit=' + options.limit);\n   }\n   if(options.offset !== undefined){\n      this.parameters.push('facet.offset=' + options.offset);\n   }\n   if(options.mincount !== undefined){\n      this.parameters.push('facet.mincount=' + options.mincount);\n   }\n   if(options.missing !== undefined){\n      this.parameters.push('facet.missing=' + options.missing);\n   }\n   if(options.method){\n      this.parameters.push('facet.method=' + options.method);\n   }\n\n   // Only supported with version 4.0 and above\n   if(this.solrVersion && (versionUtils.version(this.solrVersion) >= versionUtils.Solr4_0)) {\n     if(options.pivot){\n       options.field = arrayUtils.toArray(options.pivot.fields);\n       options.field.forEach(function(field) {\n         self.parameters.push('facet.pivot=' + field);\n       });\n     }\n     if(options.pivot.mincount) {\n       this.parameters.push('facet.pivot.mincount=' + options.pivot.mincount);\n     }\n   }\n\n   return self;\n}\n\n/**\n * Create a MoreLikeThis. MoreLikeThis constructs a lucene query based on terms within a document.\n *\n * @param {Object} options - set of options to create a morelikethis\n * @param {Boolean} [options.on=true] - Turn on or off morelikethis\n * @param {String|Array} [options.fl] - The fields to use for similarity. NOTE: if possible, these should have a stored TermVector\n * @param {Number} [options.count] - The number of similar documents to return for each result.\n * @param {Number} [options.mintf] - Minimum Term Frequency - the frequency below which terms will be ignored in the source doc.\n * @param {Number} [options.mindf] - Minimum Document Frequency - the frequency at which words will be ignored which do not occur in at least this many docs.\n * @param {Number} [options.minwl] - minimum word length below which words will be ignored.\n * @param {Number} [options.maxwl] - maximum word length above which words will be ignored.\n * @param {Number} [options.maxqt] - maximum number of query terms that will be included in any generated query.\n * @param {Number} [options.maxntp] - maximum number of tokens to parse in each example doc field that is not stored with TermVector support.\n * @param {Boolean} [options.boost] - set if the query will be boosted by the interesting term relevance.\n * @param {String|Object} [options.qf] - Query fields and their boosts using the same format as that used in DisMaxQParserPlugin. These fields must also be specified in mlt.fl.\n *\n * @return {Query}\n * @api public\n */\n\nQuery.prototype.mlt = function(options){\n  var self = this;\n  if(options.on === false){\n    this.parameters.push('mlt=false');\n  }else{\n    this.parameters.push('mlt=true');\n  }\n  if(options.fl){\n    if(options.fl instanceof Array) options.fl = options.fl.join(',');\n    this.parameters.push('mlt.fl=' + encodeURIComponent(options.fl))\n  }\n  if(options.count !== undefined){\n    this.parameters.push('mlt.count=' + options.count)\n  }\n  if(options.mintf !== undefined){\n    this.parameters.push('mlt.mintf=' + options.mintf)\n  }\n  if(options.mindf !== undefined){\n    this.parameters.push('mlt.mindf=' + options.mindf);\n  }\n  if(options.minwl !== undefined){\n    this.parameters.push('mlt.minwl=' + options.minwl)\n  }\n  if(options.maxwl !== undefined ){\n    this.parameters.push('mlt.maxwl=' + options.maxwl)\n  }\n  if(options.maxqt !== undefined){\n    this.parameters.push('mlt.maxqt=' + options.maxqt)\n  }\n  if(options.maxntp !== undefined){\n    this.parameters.push('mlt.maxntp=' + options.maxntp);\n  }\n  if(options.boost !== undefined){\n    this.parameters.push('mlt.boost=' + options.boost);\n  }\n  if(options.qf){\n    if( typeof options.qf === 'object'){\n      var parameter = querystring.stringify(options.qf, '%20' , '^');;\n    }else{\n      var parameter = encodeURIComponent(options.qf);\n    }\n    this.parameters.push('mlt.qf=' + parameter);\n  }\n  return self;\n}\n\n/*!\n * DisMax parameters\n * do not forget to use `.dismax()` when using these parameters\n */\n\n/**\n * Use the DisMax query parser\n *\n * @return {Query}\n * @api public\n */\n\nQuery.prototype.dismax = function(){\n   var self = this;\n   this.defType('dismax');\n   return self;\n}\n\n/*!\n * EDisMax parameters\n * do not forget to use `.edismax()` when using these parameters\n */\n\n/**\n * Use the EDisMax query parser\n *\n * @return {Query}\n * @api public\n */\n\nQuery.prototype.edismax = function(){\n   var self = this;\n   this.defType('edismax');\n   return self;\n}\n\n/**\n * Add the parameter debugQuery.\n * Additional debugging informations will be available in the response.\n *\n * @return {Query}\n * @api public\n */\n\nQuery.prototype.debugQuery = function(){\n   var self = this;\n   this.parameters.push('debugQuery=true');\n   return self;\n}\n\n//TODO\nQuery.prototype.ps = function(){}\n\n/**\n * Set the \"boosts\" to associate with each fields\n *\n * @param {Object} options -\n *\n * @return {Query}\n * @api public\n *\n * @example\n * var query = client.createQuery();\n * query.qf({title : 2.2, description : 0.5 });\n */\n\nQuery.prototype.qf = function(options){\n   var self = this;\n   var parameter = 'qf=' ;\n   parameter += querystring.stringify(options, '%20' , '^');\n   this.parameters.push(parameter);\n   return self;\n}\n\n/**\n * Set the minimum number or percent of clauses that must match.\n *\n * @param {String|Number} minimum - number or percent of clauses that must match\n *\n * @return {Query}\n * @api public\n *\n * @example\n * var query = client.createQuery();\n * query.mm(2); // or query.mm('75%');\n */\n\nQuery.prototype.mm = function(minimum){\n   var self = this;\n   var parameter = 'mm=' + minimum;\n   this.parameters.push(parameter);\n   return self;\n}\n\n/**\n * Set the Phrase Fields parameter.\n * Once the list of matching documents has been identified using the \"fq\" and \"qf\" params, the \"pf\" param can be used to \"boost\" the score of documents in cases where all of the terms\n * in the \"q\" param appear in close proximity.\n *\n * @param {Object} options -\n *\n * @return {Query}\n * @api public\n */\n\nQuery.prototype.pf = function(options){\n   var self = this;\n   var parameter = 'pf=' ;\n   parameter += querystring.stringify(options, '%20' , '^');\n   this.parameters.push(parameter);\n   return self;\n}\n\n/**\n * Set the phrase slop allowed in a query.\n *\n * @param {Number} slop - Amount of phrase slop allowed by the query filter. This value should represent the maximum number of words allowed between words in a field that match a phrase in the query.\n *\n * @return {Query}\n * @api public\n */\n\nQuery.prototype.ps = function(slop){\n   var self = this;\n   var parameter = 'ps=' + slop;\n   this.parameters.push(parameter);\n   return self;\n};\n\n/**\n * Set the query slop allowed in a query.\n *\n * @param {Number} slop - Amount of query slop allowed by the query filter. This value should be used to affect boosting of query strings.\n *\n * @return {Query}\n * @api public\n */\nQuery.prototype.qs = function(slop){\n   var self = this;\n   var parameter = 'qs=' + slop;\n   this.parameters.push(parameter);\n   return self;\n};\n\n/**\n * Set the tiebreaker in DisjunctionMaxQueries (should be something much less than 1)\n *\n * @param {Float|Number} tiebreaker -\n *\n * @return {Query}\n * @api public\n */\n\nQuery.prototype.tie = function(tiebreaker){\n   var self = this;\n   var parameter = 'tie=' + tiebreaker;\n   this.parameters.push(parameter);\n   return self;\n}\n\n/**\n * Set the Boost Query parameter.\n * A raw query string (in the SolrQuerySyntax) that will be included with the user's query to influence the score. If this is a BooleanQuery with a default boost (1.0f) then the individual clauses will be added directly to the main query. Otherwise, the query will be included as is.\n *\n * @param {Object} options -\n *\n * @return {Query}\n * @api public\n */\n\nQuery.prototype.bq = function(options){\n   var self = this;\n   var parameter = 'bq=' ;\n   parameter += querystring.stringify(options, '%20' , '^');\n   this.parameters.push(parameter);\n   return self;\n}\n\n\n/**\n * Set the Functions (with optional boosts) that will be included in the user's query to influence the score.\n * @param {String} functions - e.g.: `recip(rord(myfield),1,2,3)^1.5`\n *\n * @return {Query}\n * @api public\n */\n\nQuery.prototype.bf = function(functions){\n   var self = this;\n   var parameter = 'bf=' + functions;\n   this.parameters.push(parameter);\n   return self;\n}\n\n/**\n * Set the Functions (with optional boosts) that will be included in the user's query to influence the score.\n * @param {String} functions - e.g.: `recip(rord(myfield),1,2,3)^1.5`\n *\n * @return {Query}\n * @api public\n */\n\nQuery.prototype.boost = function(functions){\n   var self = this;\n   var parameter = 'boost=' + encodeURIComponent(functions);\n   this.parameters.push(parameter);\n   return self;\n}\n\n/**\n * Build a querystring with the array of `this.parameters`.\n *\n * @return {String}\n * @api private\n */\nQuery.prototype.build = function(){\n   return this.parameters.join('&');\n}\n\n/**\n * Set the Query Highlighting parameter.\n *\n * @param {Object} options - set of options for Highlighting\n * @param {Boolean} [options.on=true] - Turn on or off Highlighting\n * @param {String|Array} [options.q] - This parameters specifies and overriding query for highlighting. Multiple values specified in an array will be chained together with AND.\n * @param {String} [options.qparser] - This parameter specifies the qparser for the hl.q query.\n * @param {String|Array} [options.fl] - 'Field list.' Fields to be highlighted. Multiple fields can be entered by providing an array.\n * @param {Number} [options.snippets] - This parameter defines the maximum number of snippets to generate per field. Any number of snippets from 0 to this number can be generated per field\n * @param {Number} [options.fragsize] - This parameter defines the size, in characters, of the fragments to consider for highlighting.\n * @param {Boolean} [options.mergeContiguous] - This parameter instructs Solr to collapse continguous fragments into a single fragment.\n * @param {Number} [options.maxAnalyzedChars] - This param specifies the number of characters into a document that Solr should look for suitable snippets.\n * @param {Number} [options.maxMultiValuedToExamine] - This param specifies the max number of entries in a multi-valued field to examine before stopping\n * @param {Number} [options.maxMultiValuedToMatch] - This param specifies the maximum number of matches in a multi-valued field that are found before stopping.\n * @param {String} [options.alternateField] - Specifies a field to be used as a backup default summary if Solr cannot generate a snippet.\n * @param {Number} [options.maxAlternateFieldLength] - Specifies the maximum number of characters of the field to return. A number <=0 means the field length is unlimited.\n * @param {String} [options.formatter] - Selects a formatter for the highlighted output. At the time of writing, the only legal value is 'simple'.\n * @param {String} [options.simplePre] - This parameter defines the string to place before the data to be highlighted.\n * @param {String} [options.simplePost] - This parameter defines the string to place after the data to be highlighted.\n * @param {String} [options.fragmenter] - Specifies a text snippet generator for highlighted text. Default is 'gap' but 'regex' is another option.\n * @param {Boolean} [options.highlightMultiTerm] - Turn on or off MultiTermHighlighting. If True, Solr will use Highlight phrase terms that appear in multiple fields.\n * @param {Boolean} [options.requireFieldMatch] - If set to True, this parameter will force Solr to highlight terms only if they appear in the specified field. If false, terms are highlighted in all requested fields regardless of which field matches the query.\n * @param {Boolean} [options.usePhraseHighlighter] - If set to True, Solr will use the Lucene SpanScorer class to highlight phrase terms only when they appear within the query phrase in the document.\n * @param {Number} [options.regexSlop] - When using the regex fragmenter, this number specifies the factor by which the fragmenter can stray from the ideal fragment size.\n * @param {String} [options.regexPattern] - This parameter specifies the regulat expression for fragmenting.\n * @param {Number} [options.regexMaxAnalyzedChars] - This parameters specifies the max number of characters to analyze from a field when using the regex fragmenter.\n * @param {Boolean} [options.preserveMulti] - If True, multi-valued fields will return all values in the order they were saved in the index. If False, only values that match the highlight request will be returned.\n * @param {Boolean} [options.payloads] - If usePhraseHighlighter is True, and the indexed field has payloads but not term vectors, the index payloads will be read into the highlighter's index along with the posting. If you don't want this behavior, you may set this parameter to False and save some memory.\n\n *\n * @return {Query}\n * @api public\n */\n\nQuery.prototype.hl = function(options){\n   var self = this;\n   if(options.on === false){\n      this.parameters.push('hl=false');\n   }else{\n      this.parameters.push('hl=true');\n   }\n   if(options.q !== undefined){\n      if ( typeof(options.q) === 'string' ){\n         this.parameters.push('hl.q=' + encodeURIComponent(options.q));\n      }else{\n         this.parameters.push('hl.q=' + querystring.stringify(options.q, '%20AND%20',':'));\n      }\n   }\n   if(options.qparser !== undefined){\n      this.parameters.push('hl.qparser=' + encodeURIComponent(options.qparser));\n   }\n   if(options.fl !== undefined){\n      if ( typeof(options.fl) === 'string' ){\n         this.parameters.push('hl.fl=' + encodeURIComponent(options.fl));\n      }else{\n         this.parameters.push('hl.fl=' + options.fl.join(','));\n      }\n   }\n   if(options.snippets !== undefined){\n      this.parameters.push('hl.snippets=' + encodeURIComponent(options.snippets));\n   }\n   if(options.fragsize !== undefined){\n      this.parameters.push('hl.fragsize=' + encodeURIComponent(options.fragsize));\n   }\n   if(options.mergeContiguous !== undefined){\n      this.parameters.push('hl.mergeContiguous=' + encodeURIComponent(options.mergeContiguous));\n   }\n   if(options.requireFieldMatch !== undefined){\n      this.parameters.push('hl.requireFieldMatch=' + encodeURIComponent(options.requireFieldMatch));\n   }\n   if(options.maxAnalyzedChars !== undefined){\n      this.parameters.push('hl.maxAnalyzedChars=' + encodeURIComponent(options.maxAnalyzedChars));\n   }\n   if(options.maxMultiValuedToExamine !== undefined){\n      this.parameters.push('hl.maxMultiValuedToExamine=' + encodeURIComponent(options.maxMultiValuedToExamine));\n   }\n   if(options.maxMultiValuedToMatch !== undefined){\n      this.parameters.push('hl.maxMultiValuedToMatch=' + encodeURIComponent(options.maxMultiValuedToMatch));\n   }\n   if(options.alternateField){\n      this.parameters.push('hl.alternateField=' + encodeURIComponent(options.alternateField));\n   }\n   if(options.maxAlternateFieldLength !== undefined){\n      this.parameters.push('hl.maxAlternateFieldLength=' + encodeURIComponent(options.maxAlternateFieldLength));\n   }\n   if(options.formatter){\n      this.parameters.push('hl.formatter=' + encodeURIComponent(options.formatter));\n   }\n   if(options.simplePre){\n      this.parameters.push('hl.simple.pre=' + encodeURIComponent(options.simplePre));\n   }else{\n      this.parameters.push('hl.simple.pre=<em>');\n   }\n   if(options.simplePost){\n      this.parameters.push('hl.simple.post=' + encodeURIComponent(options.simplePost));\n   }else{\n      this.parameters.push('hl.simple.post=<%2Fem>');\n   }\n   if(options.fragmenter){\n      this.parameters.push('hl.fragmenter=' + encodeURIComponent(options.fragmenter));\n   }\n   if(options.highlightMultiTerm !== undefined){\n      this.parameters.push('hl.highlightMultiTerm=' + encodeURIComponent(options.highlightMultiTerm));\n   }\n   if(options.usePhraseHighlighter !== undefined){\n      this.parameters.push('hl.usePhraseHighlighter=' + encodeURIComponent(options.usePhraseHighlighter));\n   }\n   if(options.regexSlop !== undefined){\n      this.parameters.push('hl.regex.slop=' + encodeURIComponent(options.regexSlop));\n   }\n   if(options.regexPattern){\n      this.parameters.push('hl.regex.pattern=' + encodeURIComponent(options.regexPattern));\n   }\n   if(options.regexMaxAnalyzedChars){\n      this.parameters.push('hl.regex.maxAnalyzedChars=' + encodeURIComponent(options.regexMaxAnalyzedChars));\n   }\n   if(options.preserveMulti !== undefined){\n      this.parameters.push('hl.preserveMulti=' + encodeURIComponent(options.preserveMulti));\n   }\n   if(options.payloads !== undefined){\n      this.parameters.push('hl.payloads=' + encodeURIComponent(options.payloads));\n   }\n\n   return self;\n}\n","/home/travis/build/npmtest/node-npmtest-solr-client/node_modules/solr-client/lib/utils/format.js":"/**\n * Expose `dateISOify()` and `toISOString()`\n */\n\nexports.dateISOify = dateISOify;\nexports.toISOString = toISOString;\n\n/**\n * ISOify `Date` objects (possibly in collections)\n *\n * @param {Array|Object} obj\n *\n * @return {Array|Object}\n * @api private\n */\n\nfunction dateISOify(obj){\n   if( obj instanceof Array ){\n      for(var i = 0; i < obj.length; i++){\n         obj[i] = dateISOify(obj[i]);\n      }\n   }else if(obj instanceof Object && !(obj instanceof Date) ){\n      for(var key in obj){\n         if( obj[key] instanceof Date ) obj[key] = toISOString(obj[key]);\n      }\n   }else{\n      if( obj instanceof Date ) obj = toISOString(obj);\n   }\n   return obj;\n};\n\n/**\n * ISOify a single `Date` object\n * Sidesteps `Invalid Date` objects by returning `null` instead\n *\n * @param {Date}\n *\n * @return {null|String}\n * @api private\n */\nfunction toISOString(date) {\n   return (date && !isNaN(date.getTime())) ? date.toISOString() : null;\n};\n\n/**\n * Expose `stringify()`\n */\n\nexports.stringify = stringify;\n\n/**\n * Serialize an object to a string. Optionally override the default separator ('&') and assignment ('=') characters.\n *\n * @param {Object} obj - object to serialiaze\n * @param {String} [sep] - separator character\n * @param {String} [eq] - assignment character\n * @param {String} [name] -\n *\n * @return {String}\n * @api private\n */\n\nfunction stringify(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  obj = (obj === null) ? undefined : obj;\n\n  switch (typeof obj) {\n    case 'object':\n      return Object.keys(obj).map(function(k) {\n        if (Array.isArray(obj[k])) {\n          return obj[k].map(function(v) {\n            return stringifyPrimitive(k) +\n                   eq +\n                   stringifyPrimitive(v);\n          }).join(sep);\n        } else {\n          return stringifyPrimitive(k) +\n                 eq +\n                 stringifyPrimitive(obj[k]);\n        }\n      }).join(sep);\n\n    default:\n      if (!name) return '';\n      return stringifyPrimitive(name) + eq +\n             stringifyPrimitive(obj);\n  }\n};\n\n/**\n * Stringify a primitive\n *\n * @param {String|Boolean|Number} v - primitive value\n *\n * @return {String}\n * @api private\n */\nfunction stringifyPrimitive(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\n/**\n * Expose `escapeSpecialChars`\n */\n\n exports.escapeSpecialChars = escapeSpecialChars;\n\n /**\n  * Escape special characters that are part of the query syntax of Lucene\n  *\n  * @param {String} s - string to escape\n  *\n  * @return {String}\n  * @api public\n  */\n\nfunction escapeSpecialChars(s){\n  return s.replace(/([\\+\\-!\\(\\)\\{\\}\\[\\]\\^\"~\\*\\?:\\\\])/g, function(match) {\n    return '\\\\' + match;\n  })\n  .replace(/&&/g, '\\\\&\\\\&')\n  .replace(/\\|\\|/g, '\\\\|\\\\|');\n}\n","/home/travis/build/npmtest/node-npmtest-solr-client/node_modules/solr-client/lib/utils/array.js":"/**\n *\n * @param value\n * @param defaultIfNull - Will set the value to the default if it is Null or Undefined\n * @returns {*[]}\n */\nexports.toArray = function toArray(value, defaultIfNull) {\n  defaultIfNull = defaultIfNull || '';\n\n  function defaultValue(value) {\n    return (value === null || value === undefined) ? defaultIfNull : value;\n  }\n\n  return (Array.isArray(value)) ? value : [defaultValue(value)];\n};\n","/home/travis/build/npmtest/node-npmtest-solr-client/node_modules/solr-client/lib/utils/version.js":"/**\n * The purpose of those helpers is to centralize and standardize the work on detecting current running Solr Version\n */\n\nvar Solr3_2 = 302;\nvar Solr4_0 = 400;\nvar Solr5_0 = 500;\nvar Solr5_1 = 501;\n\n/**\n * Enum that lists supported versions of Solr. Pass one of the keys from this enum as a solrVersion property\n *\n * @type {{3.2: number, 4.0: number, 5.0: number, 5.1: number}}\n */\nvar versionsEnum = {\n  '3.2': Solr3_2,\n  '4.0': Solr4_0,\n  '5.0': Solr5_0,\n  '5.1': Solr5_1\n};\n\nexports.versionsEnum = versionsEnum;\nexports.Solr3_2 = Solr3_2;\nexports.Solr4_0 = Solr4_0;\nexports.Solr5_0 = Solr5_0;\nexports.Solr5_1 = Solr5_1;\n\n/**\n * solrVersion must match one of enum keys\n * If a number is passed, it'll be assume a .0 release (3 -> 3.0)\n * If nothing matches, it will be assumed 3.2\n *\n * @param solrVersion\n */\nexports.version = function(solrVersion) {\n  return (typeof solrVersion === \"number\") ? (versionsEnum[''+solrVersion+'.0']) : (versionsEnum[solrVersion] ? versionsEnum[solrVersion] : versionsEnum['3.2']);\n};\n","/home/travis/build/npmtest/node-npmtest-solr-client/node_modules/solr-client/lib/collection.js":"/**\n * Load dependencies\n */\nvar querystring = require('querystring'),\n    format = require('./utils/format');\n\n/**\n * Expose `Collection`\n */\n\nmodule.exports = exports = Collection;\n\n/**\n * Create a new `Collection`\n * @constructor\n *\n * @return {Collection}\n * @api private\n */\n\nfunction Collection(){\n  this.parameters = [];\n}\n\n/**\n * Set a new parameter\n * Since all possibilities provided by Solr are not available in the `Collection` object, `set()` is there to fill this gap.\n *\n * @param {String} parameter - string, special characters have to be correctly encoded or the request will fail.\n *\n * @return {Collection} - allow chaining\n * @api public\n */\nCollection.prototype.set = function(parameter){\n  var self = this;\n  this.parameters.push(parameter);\n  return self;\n}\n\n/**\n * Create a new Collection\n *\n * @param {Object} options - Set of options for creating a new collection\n * @param {String} name - The name of the collection to be created\n * @param {String} [routerName] - The router name that will be used. Default is 'compositeId'. 'implicit' is the only other valid option.\n * @param {Number} [numShards] - Number of shards to be created as part of the collection. Required when using 'compositeId' router.\n * @param {String|Array} [shards] - A comma separated list of shard names, or an array of shard names. Required if using 'implicit' router.\n * @param {Number} [replicationFactor] - The number of replicas to be created for each shard.\n * @param {Number} [maxShardsPerNode] - Sets a limit on the number of replicas CREATE will spread to each node.\n * @param {String|Array} [createNodeSet] - Defines the nodes to spread the shards/ replicas across. Comma separated list of node names, or an array of node names.\n * @param {Boolean} [createNodeSetShuffle] - Controls whether or not the shard-replicas created will be assigned to the nodes in createNodeSet in a sequential or shuffled order.\n * @param {String} [collectionConfigName] - Defines name of the configurations to use for this collection. Must already be stored in ZooKeeper.\n * @param {String} [routerField] - If specified, router will look at the value of the field in an input document to compute the hash and identify a shard instead of looking at the uniqueKey field.\n * @param {Boolean} [autoAddReplicas] - When set to true, enables auto addition of replicas on shared file systems.\n * @param {String} [async] - Request ID to track this action which will be processed asynchonously.\n\n * @return {Collection}\n * @api public\n */\nCollection.prototype.create = function(options) {\n  var self = this;\n  this.parameters.push('action=CREATE');\n  if(options.name){\n    this.parameters.push('name=' + options.name);\n  }\n  if(options.routerName){\n    this.parameters.push('router.name=' + options.routerName);\n  }\n  if(options.numShards !== undefined){\n    this.parameters.push('numShards=' + options.numShards);\n  }\n  if(options.shards !== undefined){\n    if( typeof(options.shards) === 'string') {\n      this.parameters.push('shards=' + options.shards);\n    }else{\n      this.parameters.push('shards=' + options.shards.join());\n    }\n  }\n  if(options.replicationFactor !== undefined){\n    this.parameters.push('replicationFactor=' + options.replicationFactor);\n  }\n  if(options.maxShardsPerNode !== undefined){\n    this.parameters.push('maxShardsPerNode=' + options.maxShardsPerNode);\n  }\n  if(options.createNodeSet !== undefined){\n    if( typeof(options.createNodeSet) === 'string') {\n      this.parameters.push('createNodeSet=' + options.createNodeSet);\n    }else{\n      this.parameters.push('createNodeSet=' + options.createNodeSet.join());\n    }\n  }\n  if(options.createNodeSetShuffle !== undefined){\n    this.parameters.push('createNodeSet.shuffle=' + options.createNodeSetShuffle);\n  }\n  if(options.collectionConfigName){\n    this.parameters.push('collection.configName=' + options.collectionConfigName);\n  }\n  if(options.routerField){\n    this.parameters.push('router.field=' + options.routerField);\n  }\n  if(options.autoAddReplicas !== undefined){\n    this.parameters.push('autoAddReplicas=' + options.autoAddReplicas);\n  }\n  if(options.async){\n    this.parameters.push('async=' + options.async);\n  }\n\n  return self;\n}\n\n/**\n * Reload a Collection\n * \n * @param {String} name - Name of the Collection to be reloaded\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.reload = function(name) {\n  var self = this;\n  this.parameters.push('action=RELOAD');\n  if(name){\n    this.parameters.push('name=' + name);\n  }\n\n  return self;\n}\n\n/**\n * Split a shard\n * \n * @param {Object} options - Options for splitting the shard\n * @param {String} collection - Name of the Collection that includes the shard to be split\n * @param {String} shard - Name of the shard to be split\n * @param {String|Array} [ranges] - Comma separated list of hash ranges in hexadecimal. If an array is supplied, it will be joined with commas.\n * @param {String} [splitKey] - The key to use for splitting the index\n * @param {String} [async] - Request ID to track this action, processed asynchonously.\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.splitShard = function(options) {\n  var self = this;\n  this.parameters.push('action=SPLITSHARD');\n  if(options.collection){\n    this.parameters.push('collection=' + options.collection);\n  }\n  if(options.shard){\n    this.parameters.push('shard=' + options.shard);\n  }\n  if(options.ranges !== undefined){\n    if(typeof(ranges) === 'string'){\n      this.parameters.push('ranges=' + options.ranges);\n    }else{\n      this.parameters.push('ranges=' + options.ranges.join());\n    }\n  }\n  if(options.splitKey){\n    this.parameters.push('split.key=' + options.splitKey);\n  }\n  if(options.async){\n    this.parameters.push('async=' + options.async);\n  }\n\n  return self;\n}\n\n/**\n * Create a shard\n * Can only be used for collections that use the 'implicit' router. Use SPLITSHARD for the `compositId` router.\n * \n * @param {Object} options - Options for creating the shard\n * @param {String} collection - Name of the Collection where the shard should be created\n * @param {String} shard - Name of the shard to be created\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.createShard = function(options) {\n  var self = this;\n  this.parameters.push('action=CREATESHARD');\n  if(options.collection){\n    this.parameters.push('collection=' + options.collection);\n  }\n  if(options.shard){\n    this.parameters.push('shard=' + options.shard);\n  }\n\n  return self;\n}\n\n/**\n * Delete a shard\n * \n * @param {Object} options - Options for deleting the shard\n * @param {String} collection - Name of the Collection that includes the shard to be deleted\n * @param {String} shard - Name of the shard to be deleted\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.deleteShard = function(options) {\n  var self = this;\n  this.parameters.push('action=DELETESHARD');\n  if(options.collection){\n    this.parameters.push('collection=' + options.collection);\n  }\n  if(options.shard){\n    this.parameters.push('shard=' + options.shard);\n  }\n\n  return self;\n}\n\n/**\n * Create/ Modify alias for a collection\n * \n * @param {Object} options - Options for creation of the collection alias.\n * @param {String} name - The alias name to be created.\n * @param {String|Array} collections - A comma separated list of collections to be aliased. If an array is provided, it will be joined by commas.\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.createAlias = function(options) {\n  var self = this;\n  this.parameters.push('action=CREATEALIAS');\n  if(options.name){\n    this.parameters.push('name=' + options.name);\n  }\n  if(options.collections !== undefined){\n    if(typeof(options.collections) === 'string'){\n      this.parameters.push('collections=' + options.collections);\n    } else{\n      this.parameters.push('collections=' + options.collections.join());\n    }\n  }\n\n  return self;\n}\n\n/**\n * Delete a collection alias\n * \n * @param {String} name - Name of the alias to delete\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.deleteAlias = function(name) {\n  var self = this;\n  this.parameters.push('action=DELETEALIAS');\n  if(name){\n    this.parameters.push('name=' + name);\n  }\n\n  return self;\n}\n\n/**\n * Delete a Collection\n *\n * @param {String} name - The name of the collection to be deleted\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.delete = function(name) {\n  var self = this;\n  this.parameters.push('action=DELETE');\n  if(name){\n    this.parameters.push('name=' + name);\n  }\n\n  return self;\n}\n\n/**\n * Delete a replica\n * \n * @param {Object} options - Options for deleting the replica\n * @param {String} collection - Name of the Collection that includes the replica to be deleted\n * @param {String} shard - Name of the shard that includes the replica to be deleted\n * @param {String} replica - The name of the replica to remove.\n * @param {Boolean} [onlyIfDown] - If true, deletion will only execute if the replica is down/ not active.\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.deleteReplica = function(options) {\n  var self = this;\n  this.parameters.push('action=DELETEREPLICA');\n  if(options.collection){\n    this.parameters.push('collection=' + options.collection);\n  }\n  if(options.shard){\n    this.parameters.push('shard=' + options.shard);\n  }\n  if(options.replica){\n    this.parameters.push('replica=' + options.replica);\n  }\n  if(options.onlyIfDown !== undefined){\n    this.parameters.push('onlyIfDown=' + options.onlyIfDown);\n  }\n\n  return self;\n}\n\n/**\n * Add replica\n * \n * @param {Object} options - Options for adding the replica\n * @param {String} collection - Name of the Collection\n * @param {String} shard - Name of the shard to which the replica will be added\n * @param {String} [route] - If the exact shard name is not known, route can be passed and the system will identify the shard. Ignored if shard is specified.\n * @param {String} [node] - Name of the node where the replica should be created.\n * @param {String} [async] - Request ID to track this action, which will be processed asynchronously.\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.addReplica = function(options) {\n  var self = this;\n  this.parameters.push('action=ADDREPLICA');\n  if(options.collection){\n    this.parameters.push('collection=' + options.collection);\n  }\n  if(options.shard){\n    this.parameters.push('shard=' + options.shard);\n  }\n  if(options.route){\n    this.parameters.push('_route_=' + options.route);\n  }\n  if(options.node){\n    this.parameters.push('node=' + options.node);\n  }\n  if(options.async){\n    this.parameters.push('async=' + options.async);\n  }\n\n  return self;\n}\n\n/**\n * Cluster Properties\n * \n * @param {Object} options - Options for cluster properties\n * @param {String} name - Name of the property. Two supported properties are 'urlScheme' and 'autoAddReplicas.' Others will be rejected by Solr.\n * @param {String} val - Value of the property. If the value is empty or null, the property is unset.\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.clusterProp = function(options) {\n  var self = this;\n  this.parameters.push('action=CLUSTERPROP');\n  if(options.name){\n    this.parameters.push('name=' + options.name);\n  }\n  if(options.val !== undefined){\n    this.parameters.push('val=' + options.val);\n  }\n\n  return self;\n}\n\n/**\n * Migrate documents to another collection\n * \n * @param {Object} options - Options for document migration\n * @param {String} collection - Name of the source collection from which documents will be split.\n * @param {String} targetCollection - Name of the target collection to which documents will be migrated.\n * @param {String} splitKey - The routing key prefix.\n * @param {Number} [forwardTimeout] - The timeout, in seconds, until which write requests made to the source collection for the given split.key will be forwarded to the target shard. Default is 60 seconds.\n * @param {String} [async] - Request ID to track this action which will be processed asynchronously.\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.migrate = function(options) {\n  var self = this;\n  this.parameters.push('action=MIGRATE');\n  if(options.collection){\n    this.parameters.push('collection=' + options.collection);\n  }\n  if(options.targetCollection){\n    this.parameters.push('target.collection=' + options.targetCollection);\n  }\n  if(options.splitKey){\n    this.parameters.push('split.key=' + options.splitKey);\n  }\n  if(options.forwardTimeout !== undefined){\n    this.parameters.push('forward.timeout=' + options.forwardTimeout);\n  }\n  if(options.async){\n    this.parameters.push('async=' + options.async);\n  }\n\n  return self;\n}\n\n/**\n * Add Role\n * \n * @param {Object} options - Options for adding the role\n * @param {String} role - Name of role. Only current supported role is 'overseer'\n * @param {String} node - Name of the node.\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.addRole = function(options) {\n  var self = this;\n  this.parameters.push('action=ADDROLE');\n  if(options.role){\n    this.parameters.push('role=' + options.role);\n  }\n  if(options.node){\n    this.parameters.push('node=' + options.node);\n  }\n\n  return self;\n}\n\n/**\n * Remove Role\n * Undo roles assigned using ADDROLE operation\n * \n * @param {Object} options - Options for removing the role\n * @param {String} role - Name of role. Only current supported role is 'overseer'\n * @param {String} node - Name of the node.\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.removeRole = function(options) {\n  var self = this;\n  this.parameters.push('action=REMOVEROLE');\n  if(options.role){\n    this.parameters.push('role=' + options.role);\n  }\n  if(options.node){\n    this.parameters.push('node=' + options.node);\n  }\n\n  return self;\n}\n\n/**\n * Overseer status and statistics\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.overseerStatus = function() {\n  var self = this;\n  this.parameters.push('action=OVERSEERSTATUS');\n\n  return self;\n}\n\n/**\n * Cluster status\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.clusterStatus = function() {\n  var self = this;\n  this.parameters.push('action=CLUSTERSTATUS');\n\n  return self;\n}\n\n/**\n * Request status\n * request the status of an already submitted Asynchronous Collection API call.\n *\n * @param {String} requestid - User-defined request ID from the submitted API call. A value of '-1' will clear the stored states for the already completed/ failed tasks.\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.requestStatus = function(requestid) {\n  var self = this;\n  this.parameters.push('action=REQUESTSTATUS');\n  if(requestid){\n    this.parameters.push('requestid=' + requestid);\n  }\n\n  return self;\n}\n\n/**\n * List collections\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.list = function() {\n  var self = this;\n  this.parameters.push('action=LIST');\n\n  return self;\n}\n\n/**\n * Add Replica property\n * \n * @param {Object} options - Options for replica property\n * @param {String} collection - Name of collection this replica belongs to.\n * @param {String} shard - Name of the shard the replica belongs to.\n * @param {String} replica - The name of the replica\n * @param {String} property - The property to add\n * @param {String} propertyValue - The value to assign to the property.\n * @param {Boolean} [shardUnique] - If set to true, then setting this property in one replica will remove the property from all other replicas in that shard.\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.addReplicaProp = function(options) {\n  var self = this;\n  this.parameters.push('action=ADDREPLICAPROP');\n  if(options.collection){\n    this.parameters.push('collection=' + options.collection);\n  }\n  if(options.shard){\n    this.parameters.push('shard=' + options.shard);\n  }\n  if(options.replica){\n    this.parameters.push('replica=' + options.replica);\n  }\n  if(options.property){\n    this.parameters.push('property=' + options.property);\n  }\n  if(options.propertyValue !== undefined){\n    this.parameters.push('property.value=' + options.propertyValue);\n  }\n  if(options.shardUnique !== undefined){\n    this.parameters.push('shardUnique=' + options.shardUnique);\n  }\n\n  return self;\n}\n\n/**\n * Delete Replica property\n * \n * @param {Object} options - Options for replica property\n * @param {String} collection - Name of collection this replica belongs to.\n * @param {String} shard - Name of the shard the replica belongs to.\n * @param {String} replica - The name of the replica\n * @param {String} property - The property to remove\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.deleteReplicaProp = function(options) {\n  var self = this;\n  this.parameters.push('action=DELETEREPLICAPROP');\n  if(options.collection){\n    this.parameters.push('collection=' + options.collection);\n  }\n  if(options.shard){\n    this.parameters.push('shard=' + options.shard);\n  }\n  if(options.replica){\n    this.parameters.push('replica=' + options.replica);\n  }\n  if(options.property){\n    this.parameters.push('property=' + options.property);\n  }\n\n  return self;\n}\n\n/**\n * Balance a property\n * \n * @param {Object} options - Options for replica property\n * @param {String} collection - Name of collection to balance the property in.\n * @param {String} property - The property to balance\n * @param {Boolean} [onlyActiveNodes] - Default is true. When true, property is instantiated on active nodes only. If false, inactive nodes will be included.\n * @param {Boolean} [shardUnique] - If set to true, then setting this property in one replica will r\nemove the property from all other replicas in that shard.\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.balanceShardUnique = function(options) {\n  var self = this;\n  this.parameters.push('action=BALANCESHARDUNIQUE');\n  if(options.collection){\n    this.parameters.push('collection=' + options.collection);\n  }\n  if(options.property){\n    this.parameters.push('property=' + options.property);\n  }\n  if(options.onlyActiveNodes !== undefined){\n    this.parameters.push('onlyActiveNodes=' + options.onlyActiveNodes);\n  }\n  if(options.shardUnique !== undefined){\n    this.parameters.push('shardUnique=' + options.shardUnique);\n  }\n\n  return self;\n}\n\n/**\n * Rebalance leaders\n * \n * @param {Object} options - Options for replica property\n * @param {String} collection - Name of collection to rebalance preferredLeaders on.\n * @param {Number} [maxAtOnce] - The maximum number of reassignments to have queue up at once.\n * @param {Number} [maxWaitSeconds] - Timeout value (seconds) when waiting for leaders to be reassigned. Default is 60.\n *\n * @return {Collection}\n * @api public\n */\nCollection.prototype.rebalanceLeaders = function(options) {\n  var self = this;\n  this.parameters.push('action=REBALANCELEADERS');\n  if(options.collection){\n    this.parameters.push('collection=' + options.collection);\n  }\n  if(options.maxAtOnce !== undefined){\n    this.parameters.push('maxAtOnce=' + options.maxAtOnce);\n  }\n  if(options.maxWaitSeconds !== undefined){\n    this.parameters.push('maxWaitSeconds=' + options.maxWaitSeconds);\n  }\n\n  return self;\n}\n\n/**\n * Build a querystring with the array of `this.parameters`.\n *\n * @return {String}\n * @api private\n */\nCollection.prototype.build = function(){\n  return this.parameters.join('&');\n}\n","/home/travis/build/npmtest/node-npmtest-solr-client/node_modules/solr-client/lib/error/solr-error.js":"/**\n * Module dependencies\n */\n\nvar HTTPError = require('httperror'),\n   util = require('util');\n\n/**\n * Expose `SolrError`\n */\n\nmodule.exports = SolrError;\n\n/**\n * Create a new `SolrError`\n * @constructor\n *\n * @return {SolrError}\n * @api private\n */\n\nfunction SolrError(req,res,htmlMessage){\n   var message = '';\n   if(htmlMessage){\n      var matches = htmlMessage.match(/<pre>([\\s\\S]+)<\\/pre>/);\n      message = decode((matches || ['', htmlMessage])[1].trim());\n   }\n   HTTPError.call(this, req, res, message);\n   Error.captureStackTrace(this,arguments.callee);\n   this.name = 'SolrError';\n}\n\nutil.inherits(SolrError, HTTPError);\n\n/**\n * Decode few HTML entities: &<>'\"\n *\n * @param {String} str -\n *\n * @return {String}\n * @api private\n */\nfunction decode(str) {\n  return str.replace(/&amp;/g,'&')\n            .replace(/&lt;/gm, '<')\n            .replace(/&gt;/gm, '>')\n            .replace(/&apos;/gm, '\\'')\n            .replace(/&quot;/gm, '\"');\n};\n","/home/travis/build/npmtest/node-npmtest-solr-client/node_modules/solr-client/lib/utils/type.js":"/**\n *\n * @param value - The value to check against\n * @param strict - Pass true if you want to make sure the number is fully and only composed of digits, false to just check if we can extract a number via parseInt(). Default to true.\n * @returns boolean\n */\nexports.isNumber = function isNumber(value, strict) {\n  strict = (strict === undefined ? true : strict);\n  var digitRegex = /^\\-?\\d+$/; // At least 1 digit, possibly a minus sign before\n\n  if (typeof value === 'number') {\n    return true;\n  } else {\n    // String ?\n    if (strict) {\n      return (('' + value).match(digitRegex) !== null);\n    } else {\n      return !isNaN(parseInt(value));\n    }\n  }\n};\n"}